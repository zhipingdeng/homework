---
layout: default
title: 溢出和精度&维基百科&证明
---

# part 1
## 溢出和精度
### 以下代码中，哪些出现溢出错误，哪些出现精度误差。

1）int8_t x=67   x=(0100 0011)2

int8_t y=-7      y=(1111 1001)2  

int8_t z=y-x     z=(0100 1010)2      

无溢出

2）int8_t x=0xd3   x=(1101 0011)2                                                 

溢出

3）uint8_t=0xd3      (1101 0011)2                                              

无溢出

4）int8_t x=127     x=(0111 1111)2     

int8_t y=-7         y=(1111 1001)2  

int8_t z=y-x       z=(0111 1010)2   

溢出 

5）float x=1.125      x=1.0001B                                               

无精度误差
 
6）float x=23.0      x=10111.0B                                               

无精度误差

7）float x=0.45      x=0.01(1100)(循环)B                                               

有精度误差

# part 2
## 维基百科

In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers.

The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number. 

In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers.

The term floating point refers to the fact that a number's radix point (decimal point, or, more commonly in computers, binary point) can "float"; that is, it can be placed anywhere relative to the significant digits of the number. 

## 证明1：method of complements
### 1)：二进制的负数（two‘s complement of X）等于 X 的 ones’complement ＋ 1（即，X每位求反加1）

设x=a[1]a[2]....a[k]

那么 
x + x's ones' complement=2^k-1=2^(k-1)+2^(k-2)+...2+1

即(1)x's ones' complement=2^k-1-x

=（1-a[1]）（1-a[2]）...（1-a[k]）

又因为(2)
two's complement of x=2^k-x
，所以(2)-(1)得到(3)two's complement of x=x's ones' complement+1

### 2)Int8_t x = - 017; 请用8进制描述变量 x。在c中017即(017)8

x=(761)8


## 证明2：two's complement
### 1)C程序：int8_t x = -0x1f; int y = x; 请用16进制描述变量 x 和 y，并说明 int y = x 的计算过程。

x=(E1)16,y=(FFFFFFE1)16

x=(1110 0001)2 ->y=(1111 1111 1111 1111 1111 1111 1110 0001)2 ->y=(FFFFFFE1)16

### 2)请用数学证明，为什么可以这么计算。

设x=a[k]a[k-1]a[k-2]...a[1],转换成m长度（m>k）

则100000...(m-k个0)a[k]...a[1]=1a[k]...a[1]

即x+2^k=x+2^m

->2^k-x=2^m-x

->2^k-1-x=2^m-1-x


## Floating point
### 1)NaN 是什么？

IEEE 754 specifies a special value called "Not a Number" (NaN) to be returned as the result of certain "invalid" operations, such as 0/0, ∞×0, or sqrt(−1). 